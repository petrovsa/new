<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 2.0.1"/><title data-react-helmet="true">Веб-стандарты</title><meta data-react-helmet="true" name="description" content="Сообщество разработчиков «Веб-стандарты»"/><meta data-react-helmet="true" name="keywords" content="web standards"/><link as="script" rel="preload" href="/0-152a6e34a5c4bf7cd8a5.js"/><link as="script" rel="preload" href="/component---src-templates-article-jsx-da40a148dbaf87f71d30.js"/><link as="script" rel="preload" href="/app-fdf6317c57abdf654ada.js"/><link as="script" rel="preload" href="/webpack-runtime-1400fd0a68f967e222fb.js"/><link rel="preload" href="/static/d/788/path---articles-jquery-now-what-1-ae-f98-EmA0fSpQupOsvrsNpz6E91E7hQE.json" as="fetch" crossOrigin="use-credentials"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" role="group"><header class="header"><h1>Веб-стандарты</h1></header><main><h1>Я знаю jQuery. И что?</h1><time>16 декабря 2013</time><div><h1>Я знаю jQuery. И что?</h1>
<p><a href="http://remysharp.com">Реми Шарп</a> 16 декабря 2013</p>
<p>На конференции jQuery UK 2013 я делал доклад под названием «<a href="https://speakerdeck.com/rem/i-know-jquery-now-what">Я знаю jQuery. И что?</a>». Обычно я готовлюсь, устраивая взрыв из стикеров на своём столе, но в этот раз я сперва написал пост, а потом уже сделал слайды. Итак, вот мой практически не отредактированный и немного путаный рассказ о том, как я работал с jQuery, и как я смотрю на использование встроенных браузерных технологий.</p>
<h2>7 лет назад…</h2>
<p>17 июня 2006 года я опубликовал мой самый первый настоящий <a href="http://web.archive.org/web/20061018170852/http://leftlogic.com/info/articles/auto-selecting_navigation">пост в блоге</a>: я взял обычный JavaScript и упростил его с помощью jQuery. В итоге 14 строчек JavaScript превратились в три строчки на jQuery (версии pre-1.0).</p>
<p>Самый важный эффект от jQuery был в том, что вместо муторной навигации по DOM вы писали простой CSS-селектор, после чего к нужному элементу добавлялся класс. К тому же, исходный JavaScript-код был довольно нестабильным, а разметка у вас получалась одна и та же в обоих случаях.</p>
<p>Я показал jQuery команде разработчиков, с которыми я сотрудничал в середине 2000-х, и даже дизайнеры увидели все плюсы этого подхода, поскольку CSS-селекторы были им уже знакомы (именно так и возникла идея «jQuery для дизайнеров»).</p>
<h3>Внезапно навигация по DOM стала простой</h3>
<p>В те времена навигация по DOM была очень сложной. Можно было поспорить — если у вас получалось что-то сделать в Firefox 1.5, то в IE6 это не работало.</p>
<p>Простота, с которой можно было изучить jQuery, стала для меня плюсом. Вся навигация по DOM делалась с помощью CSS-селекторов (реализовано это было какой-то безумной магией из «черного ящика», которую придумал Джон Резиг) — главное, что это экономило мои ограниченные мыслительные ресурсы, и, когда я получал нужные мне элементы DOM, я уже мог делать с ними все что угодно (показывать, скрывать, анимировать и т.п.)</p>
<h3>Понимание Ajax</h3>
<p>jQuery также поставила на доступный мне уровень абстракцию Ajax. Этот термин был придуман буквально только что, в 2005 году, и документации по технологии было мало, понять её было непросто (не забывайте про ограниченные вычислительные способности моего мозга).</p>
<p>Итак, мне нужно было работать с объектом <code>XMLHttpRequest</code>. Когда я увидел его впервые, мне стоило усилий понять, как работает событие <code>onreadystatechange</code> и пара <code>this.status</code> и <code>this.readyState</code>. jQuery, как и ряд других библиотек, разобралась с тем ужасом, который представляли собой XHR-запросы в IE через ActiveX…</p>
<pre><code>function getXmlHttpRequest() {
    var xhr;
        if (window.XMLHttpRequest) {
            xhr = new XMLHttpRequest();
    } else {
            try {
                xhr = new ActiveXObject("Msxml2.XMLHTTP");
        } catch (e) {
            try {
                xhr = new ActiveXObject("Microsoft.XMLHTTP");
        } catch (e) {
                xhr = false;
        }
    }
}
    return xhr;
}
// Код, который Джон написал в jQuery,
// куда более элегантен!
</code></pre>
<p>Когда я увидел, что в jQuery можно использовать функцию <code>ajax</code>, для того чтобы выцепить HTML по какому-то адресу (именно это мы обычно и хотели делать с помощью Ajax), вся технология внезапно стала для меня понятной.</p>
<p>jQuery сразу и надолго стала моим обычным инструментом. Это был мой «швейцарский нож», если позаимствовать <a href="http://events.jquery.org/2013/uk/schedule.html#adam">название доклада Адама</a>!</p>
<h2>Назад в будущее: сегодня</h2>
<p>Давайте промотаем ленту вперед и вернемся в сегодняшний день. Что случилось за эти годы?</p>
<p>Для начала: моя позиция по умолчанию — это не «всегда подключай jQuery». Я лучше знаю JavaScript, и как в нём все работает. У меня появились собственные критерии, когда нужно подключать jQuery, а когда нет. Но если я не подключаю jQuery, что тогда?</p>
<p>За эти семь лет произошло довольно многое. Вероятно, одним из самых важных шагов вперед стало появление в браузерах <code>querySelectorAll</code>.</p>
<p>Возможность передать встроенной функции внутри браузера CSS-селектор, чтобы сам браузер работал над навигацией по DOM — это огромная (правда!) часть jQuery. Базовая поддержка была в Chrome с самого начала, в IE8 и Firefox 3.5 появилась в середине 2009 года.</p>
<p>Эндрю Ланни (из PhoneGap и Adobe) написал невероятно простую функцию:</p>
<pre><code>var $ = document.querySelectorAll.bind(document);
Element.prototype.on = Element.prototype.addEventListener;

$('#somelink')[0].on('touchstart', handleTouch);
</code></pre>
<p>Это просто и прекрасно.</p>
<p>Я взял его идею, немного развил ее и использовал в ряде довольно специфических проектов, добавив поддержку для чейнинга, циклов и упростив синтаксис. В сжатом виде все занимает меньше 200 байт. Смысл этого в том, что сейчас у нас есть встроенная в браузеры поддержка для ряда функций, и я стараюсь принимать во внимание аудиторию своего проекта, перед тем как по умолчанию подключать jQuery.</p>
<h2>В каких случаях я всегда использую jQuery</h2>
<p>Прежде чем я расскажу о том, как я могу обходиться без jQuery, быть «нагим» — давайте я расскажу о случаях, когда я точно включаю jQuery в проект. Есть несколько довольно специфических причин, которые заставляют меня либо начинать прямо с jQuery, либо переключаться на нее с какого-то специально написанного решения.</p>
<p>Перед этим я должен оговориться относительно случая, когда я абсолютно точно не использую jQuery: если я пытаюсь воспроизвести баг в браузере, я никогда не использую библиотеку. Если вы пытаетесь найти баг, чтобы можно было сообщить о проблеме, необходимо, чтобы в примере было как можно меньше кода (конечно, кроме тех случаев, когда вы отправляете сообщение об ошибке внутри jQuery!).</p>
<h3>1. Когда проект должен работать в устаревших браузерах</h3>
<p>BBC достаточно четко озвучили, <a href="http://responsivenews.co.uk/post/18948466399/cutting-the-mustard">что именно они называют современным браузером</a>, и по некотором размышлении это и есть тот признак, по которому я решаю, включать jQuery по умолчанию или нет.</p>
<p>Если я знаю, что я должен работать с несовременными браузерами, и они составляют часть ядра аудитории, то я начну с jQuery внутри своего кода.</p>
<p>Что значит «современный»? По большому счету, ответ простой: поддерживает ли браузер <code>querySelectorAll</code>? BBC применяет следующий тест на соответствие требованию современности:</p>
<pre><code>if (querySelector in document &#x26;&#x26;
    localStorage in window &#x26;&#x26;
    addEventListener in window) {
    // Загружаем JavaScript-приложение
}
</code></pre>
<p>Я знаю наизусть, что IE8 не поддерживает <code>addEventListener</code> (<a href="https://gist.github.com/eirikbacker/2864711">хотя и существует полифил</a>), так что, если поддержка этого браузера важна для проекта, я понимаю, что не хочу начинать проект с хаков для IE8.</p>
<p>Не то чтобы я хочу сказать, что те проекты, которые я начинаю без jQuery, не будут поддерживать IE8. Скорее — что нужно начинать с малого и делать разработку простой с самого начала. Если я начну проект с охапки хаков — проблем не оберёшься.</p>
<p>И еще я считаю это тем случаем, «когда сложность перевешивает простоту».</p>
<h3>2. Когда я делаю что-то дешево и сердито</h3>
<p>Если я создаю какой-то концепт, тестирую идею или просто что-то набрасываю и отправляю в <a href="http://jsbin.com">JS Bin</a>, обычно я просто добавляю jQuery по умолчанию. Так мне не приходится лишний раз думать.</p>
<h2>Без jQuery!</h2>
<p>Наверное, вы думаете: «Так, Реми использует jQuery, а если нет, то просто переписывает все фичи сам?»</p>
<p>Я совершенно не хочу изобретать велосипед. Если я обнаруживаю, что, разрабатывая без jQuery, я в итоге сам переписываю с нуля ее функциональность, тогда, ясное дело, я просто трачу свое время впустую.</p>
<p>Нет, всё не так. Просто есть довольно много сценариев, в которых я буду писать код своего приложения без библиотеки, опираясь на встроенные в браузер технологии. Если какая-то часть этих технологий не поддерживается в том или ином браузере, я могу прибегнуть к <a href="http://remysharp.com/2010/10/08/what-is-a-polyfill/">полифилам</a> — но только после тщательного рассмотрения и понимания, что это имеет смысл.</p>
<p>Итак, как я живу без jQuery, и насколько полной можно считать поддержку нужных технологий в браузерах?</p>
<h2>document.ready</h2>
<p>Даже когда я использую jQuery, если у меня (или моей компании) есть контроль над проектом, я очень редко использую <code>document.ready</code> (или его короткую версию: <code>$(function)</code>).</p>
<p>Дело в том, что весь JavaScript я размещаю под всем DOM, перед тегом <code>&#x3C;/body></code>. Так я всегда уверен, что в этот момент весь DOM уже будет обработан браузером.</p>
<p>Надеюсь, что вы это и так знаете, но JavaScript блокирует рендеринг страницы. Если вы разместите JavaScript над содержимым, и ваш сервер подвиснет — вы получите пустую страницу. Я много раз уже использовал этот пример, но повторюсь, что раньше (довольно давно) виджет Twitter просто вставлялся в HTML вашей страницы. Их сайт частенько падал, и мой блог (с этим виджетом) зависал на пустой странице — так что выглядело все так, будто упал мой сайт.</p>
<h2>.attr('value') и .attr('href')</h2>
<p>Мне всегда становится грустно, когда я вижу, как jQuery используется для того, чтобы получить значение элемента <code>&#x3C;input></code>:</p>
<pre><code>$('input').on('change', function () {
    var value = $(this).attr('value');
    alert('The new value is' + value);
});
</code></pre>
<p>Почему? Потому что всегда можно получить значение элемента с помощью <code>this.value</code>. Что важнее — нужно думать о том, как вы используете JavaScript-библиотеку. Не применяйте jQuery без необходимости.</p>
<p>Дело здесь не в jQuery. Это просто нормальная практика. Нужно, чтобы в коде просто было написано:</p>
<pre><code>$('input').on('change', function () {
    alert('The new value is' + this.value);
});
</code></pre>
<p>Еще люди довольно часто используют jQuery для того, чтобы получить <code>href</code> ссылки: <code>$(this).attr('href')</code>, но можно вполне легко получить путь и из DOM: <code>this.href</code>. Обратите, правда, внимание, что <code>this.href</code> несколько отличается: это абсолютный путь, поскольку мы здесь говорим про DOM API, а не сам элемент. Если вы хотите получить значение атрибута (как это работает в случае jQuery), вы можете использовать <code>this.getAttribute('href')</code>.</p>
<p>Ещё есть сценарий, в котором вы устанавливаете класс для элемента, и здесь вам тоже не нужна jQuery, если вы просто добавите класс. Сколько раз я видел:</p>
<pre><code>    &#x3C;script src="http://code.jquery.com/jquery.min.js">&#x3C;/script>
&#x3C;/head>
&#x3C;body>
    &#x3C;script>
        $('body').addClass('hasJS');
    &#x3C;/script>
</code></pre>
<p>Но зачем, когда можно так?</p>
<pre><code>&#x3C;/head>
&#x3C;body>
    &#x3C;script>
        document.body.className = 'hasJS';
    &#x3C;/script>
</code></pre>
<p>Пожалуй, самое главное различие между этими двумя примерами состоит в том, что мы не подключаем jQuery только затем, чтобы установить класс для <code>&#x3C;body></code>, определяющий доступность JavaScript.</p>
<p>Если у <code>&#x3C;body></code> уже может быть какой-нибудь класс, то просто припишите новый к строке (jQuery тоже нужно обращаться к свойству <code>className</code>): <code>document.body.className += ' hasJS'</code>.</p>
<p>Здесь мы начинаем натыкаться на проблемы с именами классов и отслеживанием того, у каких элементов какой класс есть, а какого нет. Но в браузерах есть и такая функциональность.</p>
<h2>classList — добавляем, удаляем, переключаем</h2>
<p>Свойство <code>classList</code> из спецификации HTML5 поддерживается всеми последними версиями браузеров (кроме IE9 — но в этом случае я могу использовать полифил).</p>
<p>Вместо:</p>
<pre><code>$('body').addClass('hasJS');
// или
document.body.className += ' hasJS';
</code></pre>
<p>Можно написать:</p>
<pre><code>document.body.classList.add('hasJS');
</code></pre>
<p>Красиво, не правда ли? А удалять?</p>
<pre><code>$('body').removeClass('hasJS');
// или какое-нибудь безумное регулярное выражение
</code></pre>
<p>Или можно сделать так:</p>
<pre><code>document.body.classList.remove('hasJS');
</code></pre>
<p>Но больше впечатляет встроенная поддержка переключения классов:</p>
<pre><code>document.body.classList.toggle('hasJS');
// и
document.body.classList.contains('hasJS');
</code></pre>
<p>Для добавления нескольких классов нужно добавить их как аргументы через запятую:</p>
<pre><code>document.body.classList.add('hasJS', 'ready');
</code></pre>
<p>Есть, конечно, некоторые проблемы, вроде этой, с пустой строкой:</p>
<pre><code>document.body.classList.contains('');
// SyntaxError: DOM Exception 12
</code></pre>
<p>Ужасно! Но, с другой стороны, я знаю проблемные места и обхожу их стороной. В принципе, мы выросли, работая с браузерами именно по таким принципам.</p>
<h2>Хранение данных</h2>
<p>Хранение произвольных данных в элементах появилось в jQuery в версии 1.2.3, а хранение объектов — в 1.4, то есть уже довольно давно.</p>
<p>В HTML5 есть встроенное хранение данных внутри элементов, но между jQuery и встроенной поддержкой есть фундаментальная разница: <code>dataset</code> в HTML5 не поддерживает хранение объектов.</p>
<p>Но если вы храните строки или JSON, тогда встроенная поддержка работает идеально:</p>
<pre><code>element.dataset.user = JSON.stringify(user);
element.dataset.score = score;
</code></pre>
<p>К сожалению, встроенной поддержки нет в IE10 (конечно, можно добавить полифил, и все прекрасно заработает — но это нужно принимать во внимание при использовании <code>dataset</code>).</p>
<h2>Ajax</h2>
<p>Как я уже говорил, jQuery помогла мне понять Ajax в полной мере. Сейчас Ajax — это довольно просто. Конечно, у меня нет всяких дополнительных опций, но, по большей части я просто выполняю XHR GET или POST-запросы с JSON.</p>
<pre><code>function request(type, url, opts, callback) {
    var xhr = new XMLHttpRequest(),
        fd;

    if (typeof opts === 'function') {
        callback = opts;
        opts = null;
}

    xhr.open(type, url);

    if (type === 'POST' &#x26;&#x26; opts) {
        fd = new FormData();

        for (var key in opts) {
            fd.append(key, JSON.stringify(opts[key]));
    }
}

    xhr.onload = function () {
        callback(JSON.parse(xhr.response));
};

    xhr.send(opts ? fd : null);
}

var get = request.bind(this, 'GET');
var post = request.bind(this, 'POST');
</code></pre>
<p>Коротко и просто. XHR — это совсем не сложно, а сейчас есть и хорошая документация. Понимание того, как XHR на самом деле работает и что с его помощью можно сделать, дает нам больше возможностей.</p>
<p>Как насчет событий прогресса? Событий, привязанных к прогрессу загрузки? Что насчёт отправки <code>ArrayBuffer</code>? А если нужно разбираться с <a href="http://ru.wikipedia.org/wiki/Cross-origin_resource_sharing">CORS</a> и заголовком <code>xml-requested-with</code>?</p>
<p>Для этого вам понадобится прямой доступ к объекту XHR (я знаю, что это можно получить и из jQuery), и вам нужно знать, как устроен XHR и что с ним можно делать, потому что такие вещи, как, например, загрузку файлов через перетаскивание сейчас безумно просто реализовать с помощью встроенной функциональности.</p>
<h2>Наконец-то формы!</h2>
<p>jQuery-плагин для валидации форм был стабильным плагином с первых дней jQuery, и честно сделал работу с формами намного проще.</p>
<p>Но вне зависимости от валидации на стороне клиента все равно нужно проводить валидацию на стороне сервера — это необходимо в любом случае, какую бы валидацию вы ни делали.</p>
<p>Но что, если можно было бы выбросить кучу строк JavaScript и плагинов и валидировать эл. адрес как-то так:</p>
<pre><code>&#x3C;input type="email">
</code></pre>
<p>Хотите сделать его обязательным полем?</p>
<pre><code>&#x3C;input type="email" required>
</code></pre>
<p>Хотите разрешать пользователю вводить только определенные символы?</p>
<pre><code>&#x3C;input pattern="a-z0-9">
</code></pre>
<p>Неплохо. Здесь даже есть поддержка вспомогательных технологий — например, клавиатура на мобильных устройствах адаптируется и будет выводить символы для эл. адреса.</p>
<p>Так как все эти типы полей при отсутствиии в браузере поддержки просто становятся текстовыми полями, и раз уж вам все равно нужно делать валидацию на сервере, я бы на вашем месте выкинул всю JavaScript-валидацию и заменил ее на встроенную в браузеры валидацию HTML5-форм.</p>
<h2>jQuery-анимации против CSS-анимаций и JavaScript-анимаций</h2>
<p>На самом деле это никакое не соревнование. CSS выигрывает. Анимации, для которых используется CSS, вычисляются на видеокарте. В анимациях на JavaScript добавляется еще один уровень расчетов — просто потому, что там есть JavaScript.</p>
<p>Даже в том случае, когда я пишу код сам, я выберу <code>requestAnimationFrame</code> вместо использования анимаций, основанных на <code>setInterval</code>.</p>
<p>Джейк Арчибальд подготовил отличные слайды, которые показывают проблему — <code>setInterval</code> не сделает анимацию плавной, и достаточно скоро начнет пропускать кадры:</p>
<figure>
    
  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 510px; margin-left: auto; margin-right: auto;">
    <span class="gatsby-resp-image-background-image" style="padding-bottom: 75.09803921568627%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAEDAgX/xAAWAQEBAQAAAAAAAAAAAAAAAAAAAgP/2gAMAwEAAhADEAAAAeo3vO4lA//EABkQAAIDAQAAAAAAAAAAAAAAAAACARETEv/aAAgBAQABBQKEWs1M1Ios6P/EABYRAAMAAAAAAAAAAAAAAAAAAAABEf/aAAgBAwEBPwGsrP/EABgRAAIDAAAAAAAAAAAAAAAAAAABAhES/9oACAECAQE/AcxKR//EABgQAAIDAAAAAAAAAAAAAAAAAAAyASAx/9oACAEBAAY/AsFFin//xAAbEAEBAAEFAAAAAAAAAAAAAAABABARMVFh4f/aAAgBAQABPyFmzdefInoHFHN//9oADAMBAAIAAwAAABBQD//EABURAQEAAAAAAAAAAAAAAAAAAABh/9oACAEDAQE/EDR//8QAFREBAQAAAAAAAAAAAAAAAAAAARD/2gAIAQIBAT8QIX//xAAcEAEAAgEFAAAAAAAAAAAAAAABABExIWGRscH/2gAIAQEAAT8QEl+htGCGuhEIzREhfke4cM//2Q==&apos;); background-size: cover; display: block;">
      <img class="gatsby-resp-image-image" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px transparent;" alt="set timeout" title="" src="/static/339a76bf8fed5e9f1d0e4e1217f2340f/3ecdc/set-timeout.jpg" srcset="/static/339a76bf8fed5e9f1d0e4e1217f2340f/5cba7/set-timeout.jpg 163w,
/static/339a76bf8fed5e9f1d0e4e1217f2340f/cf009/set-timeout.jpg 325w,
/static/339a76bf8fed5e9f1d0e4e1217f2340f/3ecdc/set-timeout.jpg 510w" sizes="(max-width: 510px) 100vw, 510px">
    </span>
  </span>
  
    
  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 510px; margin-left: auto; margin-right: auto;">
    <span class="gatsby-resp-image-background-image" style="padding-bottom: 75.09803921568627%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAMBBf/EABcBAAMBAAAAAAAAAAAAAAAAAAABAgP/2gAMAwEAAhADEAAAAepqmVRUM//EABkQAAIDAQAAAAAAAAAAAAAAAAACARETEv/aAAgBAQABBQKEWs1M1Ios6P/EABYRAAMAAAAAAAAAAAAAAAAAAAABEf/aAAgBAwEBPwGsrP/EABgRAAIDAAAAAAAAAAAAAAAAAAABAhES/9oACAECAQE/AcxKR//EABgQAAIDAAAAAAAAAAAAAAAAAAAxASAy/9oACAEBAAY/AkZFFP/EABoQAQEAAgMAAAAAAAAAAAAAAAEAETFRYeH/2gAIAQEAAT8hZputPnWQGxkc3//aAAwDAQACAAMAAAAQfz//xAAVEQEBAAAAAAAAAAAAAAAAAAAAYf/aAAgBAwEBPxCqj//EABYRAQEBAAAAAAAAAAAAAAAAAAABYf/aAAgBAgEBPxCDN//EABoQAQEBAAMBAAAAAAAAAAAAAAEAETFhwZH/2gAIAQEAAT8QGizh1MYHyTQbuEkb5PeHxv/Z&apos;); background-size: cover; display: block;">
      <img class="gatsby-resp-image-image" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px transparent;" alt="request animation frame" title="" src="/static/baddf361410b4c8155d5b69297ad2890/3ecdc/request-animation-frame.jpg" srcset="/static/baddf361410b4c8155d5b69297ad2890/5cba7/request-animation-frame.jpg 163w,
/static/baddf361410b4c8155d5b69297ad2890/cf009/request-animation-frame.jpg 325w,
/static/baddf361410b4c8155d5b69297ad2890/3ecdc/request-animation-frame.jpg 510w" sizes="(max-width: 510px) 100vw, 510px">
    </span>
  </span>
  
</figure>
<p>Кроме того, CSS-анимации проходят через тот же таймер, что и <code>requestAnimationFrame</code> — его мы и хотим использовать.</p>
<p>Так что, если ваш браузер это позволяет, используйте CSS-анимации. Конечно, это посложнее, чем <code>$foo.animate('slow', { x: '+=10px' })</code>, но зато анимация будет чище и плавнее. Стоит знать, что трогать DOM — дорогая операция. Если вы анимируете положение элемента по оси абсцисс, обновляя атрибут <code>el.style.left</code>, вы постоянно читаете и пишете в DOM.</p>
<p>А вот если вы просто сделаете <code>foo.classList.add('animate')</code>, анимация CSS-класса выполнит плавный переход положения левой точки элемента. И если вы точно знаете, что это только значение слева, можно использовать аппаратное ускорение, выполнив <code>translateX</code> с <code>translateZ(0)</code>.</p>
<p>Ну а как же, слышу я ваш крик, как же вызов функции после окончания анимации? Это тоже можно. Хотя синтаксис немножко противный:</p>
<pre><code>el.addEventListener("webkitTransitionEnd", transitionEnded);
el.addEventListener("transitionend", transitionEnded);
</code></pre>
<p>Обратите внимание, что <code>e</code> в <code>end</code> строчная…</p>
<p>Пара милых людей в Твиттере показали мне <a href="https://github.com/benbarnett/jQuery-Animate-Enhanced">своего рода полифил для jQuery</a>, который дополняет функцию <code>.animate</code> в том случае, если в браузере доступны CSS-анимации.</p>
<p>Еще есть отдельный плагин <a href="http://ricostacruz.com/jquery.transit/">Transit</a>, который дает вам возможность писать CSS-анимации на JavaScript. Приятный момент для меня — поддержка чейнинга. Но так он работает только с CSS-анимациями, для этого требуется IE10 или выше.</p>
<p>Отсюда у меня возникает вопрос: почему этот плагин в обязательном порядке требует jQuery?</p>
<h2>В сторону: jQuery-плагины — просто так</h2>
<p>Я:</p>
<blockquote>
<p>Не знаю почему, но мне очень хочется больно ударить людей, которые пишут такие jQuery-плагины, для которых на самом деле jQuery совершенно не нужна. /требуется-контроль-эмоций</p>
</blockquote>
<p>Ответ:</p>
<blockquote>
<p>@rem У меня то же самое. Я думаю, где-то есть группа, в которой с этим помогают, — и, полагаю, довольно большая.</p>
</blockquote>
<p>Я недавно работал над проектом и узнал о <a href="http://fittextjs.com">fitText.js</a>. Я решил включить его в свой код, но потом заметил, что для него <strong>требуется</strong> jQuery.</p>
<p>Хм-м. Зачем?</p>
<p>Этот проект использует следующие методы jQuery:</p>
<ol>
<li><code>.extend</code></li>
<li><code>.each</code></li>
<li><code>.width</code></li>
<li><code>.css</code></li>
<li><code>.on</code> (над производительностью никто особенно не задумывался)</li>
</ol>
<p>Собственно, вот код проекта:</p>
<pre><code>$.fn.fitText = function( kompressor, options ) {

    // Настраиваем
    var compressor = kompressor || 1,
        settings = $.extend({
            'minFontSize' : Number.NEGATIVE_INFINITY,
            'maxFontSize' : Number.POSITIVE_INFINITY
    }, options);

    return this.each(function(){

        // Сохраняем объект
        var $this = $(this);

        // Функция Resizer() изменяет размеры объекта
        // на основе его ширины, поделённой на compressor * 10
        var resizer = function () {
            $this.css('font-size', Math.max(
                Math.min($this.width() / (compressor*10),
                parseFloat(settings.maxFontSize)
            ),
            parseFloat(settings.minFontSize)));
    };

        // Вызываем для установки
        resizer();

        // Вызываем при ресайзе. Opera кеширует вызовы по умолчанию
        $(window).on('resize orientationchange', resizer);
});
};
</code></pre>
<p><code>.extend</code> используется на объекте, в котором всего две опции, так что я бы переписал его так:</p>
<pre><code>if (options === undefined) options = {};
if (options.minFontSize === undefined) options.minFontSize = Number.NEGATIVE_INFINITY;
if (options.maxFontSize === undefined) options.maxFontSize = Number.POSITIVE_INFINITY;
</code></pre>
<p><code>return this.each</code> используется для того, чтобы итерироваться по элементам. Предположим, что мы хотим, чтобы этот код работал без jQuery: тогда наша функция <code>fitText</code> получит список элементов (так как чейнинга мы делать не будем):</p>
<pre><code>var length = nodes.length,
    i = 0;

// Хотелось бы использовать [].forEach.call, но нет поддержки в IE8
for (; i &#x3C; length; i++) {
    (function (node) {
        // там, где использовался `this`, теперь `node`
        // …
    })(nodes[i]);
}
</code></pre>
<p><code>$this.width()</code> получает ширину контейнера, чтобы изменять размер текста. Для этого нам нужно получить рассчитанные стили и взять из них значение ширины:</p>
<pre><code>// Функция Resizer() изменяет размеры объекта
// на основе его ширины, поделённой на compressor * 10
var resizer = function () {
    var width = node.clientWidth;
    // …
};
</code></pre>
<p><code>$this.css</code> используется для установки значений, так что тут всего лишь нужно задать стили:</p>
<pre><code>node.style.fontSize = Math.max(…);
</code></pre>
<p><code>$(window).on('resize', resizer)</code> прикрепляет обработчик события (если вы хотите поддержку в IE8, то нужно еще включить <code>addEvent</code>):</p>
<pre><code>window.addEventListener('resize', resizer, false);
</code></pre>
<p>На самом деле, я бы пошел еще дальше и хранил бы функции ресайза в массиве, и во время операции изменения размера проходил бы по массиву, исполняя все эти функции.</p>
<p>Конечно, тут нужно немножко больше работы, но при этом такие изменения довольно легко провести так, чтобы работа в качестве jQuery-плагина была бы для этого проекта дополнительной функциональностью, а не требованием.</p>
<p>Моя тирада скоро закончится: еще меня убивает, когда я вижу полифил, которому требуется jQuery — но я признаю и контраргумент: чрезвычайная распространенность jQuery, наверное, может оправдать то, что столько проектов пишется с зависимостью от нее.</p>
<h2>Заключение</h2>
<p>Моей целью было показать вам, что, хотя jQuery безумно помогала мне все эти годы (особенно годы плохой совместимости между браузерами), и со встроенной функциональностью браузеров можно уйти довольно далеко в плане обычных сценариев, — когда я пишу JavaScript для того, чтобы «сделать что-нибудь» в DOM.</p>
<p>Перестаньте думать в парадигме «функция X не работает в браузере Y». Подходите с другой точки зрения. Какую задачу я решаю? Какой инструмент лучше всего подойдет? Для кого это делается? Я по-прежнему верю в методологию прогрессивного улучшения, но я не понимаю удовольствия лезть из кожи вон ради того, чтобы поддерживать воображаемую аудиторию пользователей (по той причине, что у нас нет данных, какие браузеры у наших пользователей).</p>
<p>Google (по моим последним данным) поддерживает последние и предпоследние версии браузеров. Я тоже стараюсь начинать с поддержки этих версий.</p>
<p>Я буду продолжать использовать jQuery так, как мне удобно, и я продолжу убеждать своих читателей и слушателей, что фронтенд-разработчики должны знать, что могут браузеры, с которыми они работают.</p>
<p>Итак, на этом я заканчиваю и надеюсь, что этот текст был вам полезен.</p>
<p>Возможно, некоторые из вас уже знали всё это (правда, в таком случае у меня возникает вопрос, зачем вы это читаете), однако я надеюсь, что хоть кому-то я показал, что за пределами jQuery есть еще целый мир, и вы можете начать осваивать его прямо сейчас в одном из своих проектов.</p>
<p>Может быть, некоторые из вас только знакомятся с jQuery — я надеюсь, что вы станете разбираться и дальше в том, на что способны JavaScript и DOM.</p>
<p>Однако большинству из вас я принёс снег зимой. Вы уже согласны со мной. Вы уже верите в стандарты, делаете все правильно, учитесь и образовываетесь. Но вы должны помочь людям, которые не получают этой информации.</p>
<p>Вам нужно делиться своими ощущениям с другими людьми. Теперь вы — эксперты, и вы должны помочь окружающим достигнуть вашего уровня и превзойти его.</p>
<p>На конференциях будут нужны новые докладчики и новые эксперты: это вы.</p>
<h2>Материалы к статье</h2>
<ul>
<li><a href="https://speakerdeck.com/rem/i-know-jquery-now-what">Слайды презентации</a></li>
<li><a href="http://vimeo.com/68009123">Видео доклада</a></li>
<li><a href="http://vimeo.com/68910118#t=2380">Секция вопросов и ответов с конференции Mobilism</a></li>
<li><a href="https://github.com/remy/min.js">Библиотека min.js</a></li>
</ul>
<p>Перевод оригинальной записи «<a href="http://remysharp.com/2013/04/19/i-know-jquery-now-what/">I know jQuery. Now what?</a>» Реми Шарпа (Remy Sharp), опубликованной на сайте <a href="http://remysharp.com">remy sharp’s b:log</a>. Переведено и опубликовано с разрешения автора.</p>
<p>Перевод <a href="http://www.facebook.com/vlad.andersen">Влада Андерсена</a>, редактура <a href="http://pepelsbey.net">Вадима Макеева</a> и <a href="http://engel-t.moikrug.ru">Ольги Алексашенко</a>.</p></div></main><footer class="footer"><p>2018 © Веб-стандарты</p></footer></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.page={"componentChunkName":"component---src-templates-article-jsx","jsonName":"articles-jquery-now-what-1ae","path":"/articles/jquery-now-what/"};window.dataPath="788/path---articles-jquery-now-what-1-ae-f98-EmA0fSpQupOsvrsNpz6E91E7hQE";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"app":["/app-fdf6317c57abdf654ada.js"],"component---src-templates-article-list-jsx":["/component---src-templates-article-list-jsx-d6fdd15edf4f8b89c17b.js"],"component---src-templates-article-jsx":["/component---src-templates-article-jsx-da40a148dbaf87f71d30.js"],"component---src-pages-404-jsx":["/component---src-pages-404-jsx-a85f47ff49f987715412.js"],"component---src-pages-events-jsx":["/component---src-pages-events-jsx-4f883960193822a95f04.js"],"component---src-pages-index-jsx":["/component---src-pages-index-jsx-6d406cab1d4cc5f63755.js"]};/*]]>*/</script><script src="/webpack-runtime-1400fd0a68f967e222fb.js" async=""></script><script src="/app-fdf6317c57abdf654ada.js" async=""></script><script src="/component---src-templates-article-jsx-da40a148dbaf87f71d30.js" async=""></script><script src="/0-152a6e34a5c4bf7cd8a5.js" async=""></script></body></html>