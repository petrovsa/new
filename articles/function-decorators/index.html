<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 2.0.1"/><title data-react-helmet="true">Веб-стандарты</title><meta data-react-helmet="true" name="description" content="Сообщество разработчиков «Веб-стандарты»"/><meta data-react-helmet="true" name="keywords" content="web standards"/><link as="script" rel="preload" href="/0-152a6e34a5c4bf7cd8a5.js"/><link as="script" rel="preload" href="/component---src-templates-article-jsx-da40a148dbaf87f71d30.js"/><link as="script" rel="preload" href="/app-fdf6317c57abdf654ada.js"/><link as="script" rel="preload" href="/webpack-runtime-1400fd0a68f967e222fb.js"/><link rel="preload" href="/static/d/232/path---articles-function-decorators-a-52-9b0-IUfP8y9vcIi9qeFIAX5ZEFN8k.json" as="fetch" crossOrigin="use-credentials"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" role="group"><header class="header"><h1>Веб-стандарты</h1></header><main><h1>Функции-декораторы, которые можно написать с нуля</h1><time>TODO</time><div><h1>Функции-декораторы, которые можно написать с нуля</h1>
<p>Перевод «Here are a few function decorators you can write from scratch» Кристи Сальсезку.</p>
<p><img src="https://cdn-images-1.medium.com/max/10392/1*Qw0e4LC2Fri7dFkBY0N1cA.jpeg" alt="Фото [Calum Lewis](https://unsplash.com/photos/rkT_TG5NKF8)."><em>Фото <a href="https://unsplash.com/photos/rkT_TG5NKF8">Calum Lewis</a>.</em></p>
<blockquote>
<h1>Декораторы — это функции высшего порядка, которые принимают в качестве аргумента одну функцию и возвращают другую. Возвращаемая функция является преобразованным вариантом функции-аргумента <a href="https://leanpub.com/javascript-allonge/read#decorators">*Javascript Allongé</a>*</h1>
</blockquote>
<p>Давайте самостоятельно напишем некоторые базовые дектораторы, представленные в таких библиотеках, как <a href="http://underscorejs.org/#functions">*underscore.js</a><em>, [</em>lodash.js](<a href="https://lodash.com/docs/4.17.5">https://lodash.com/docs/4.17.5</a>)<em>, [</em>ramda.js](<a href="http://ramdajs.com/docs/">http://ramdajs.com/docs/</a>)*.</p>
<h2>once()</h2>
<ul>
<li>
<p><a href="https://jsfiddle.net/cristi_salcescu/zpLeLp0v/">once(fn)</a> создает экземпляр функции, которая должна быть выполнена только один раз. Паттерн может быть использован, например, для инициализации, когда нужно быть уверенным в единичном запуске функциональности, даже если сама функция вызвана в нескольких местах.</p>
<p>function once(fn){
let returnValue;
let canRun = true;
return <strong>function runOnce(){
if(canRun) {
returnValue = fn.apply(this, arguments);
canRun = false;
}
return returnValue;
}</strong>
}</p>
<p>var processonce = once(process);
processonce(); // process
processonce(); //</p>
</li>
</ul>
<p>Функция once() возвращает другую функцию — runOnce(), использующую <a href="https://medium.freecodecamp.org/why-you-should-give-the-closure-function-another-chance-31253e44cfa0">замыкание</a>. Обратите также внимание, как осуществлен вызов оригинальной функции, а именно через передачу this и arguments в метод apply: fn.apply(this, arguments).</p>
<p>Если хотите узнать замыкания глубже, обратите внимание на статью «<a href="https://medium.com/p/31253e44cfa0">Why you should give the Closure function another chance</a>».</p>
<h2>after()</h2>
<ul>
<li>
<p><a href="https://jsfiddle.net/cristi_salcescu/4evuoxe6/">after(count, fn)</a> создает вариант функции, которая будет выполнена только после определенного количества вызовов. Функция полезна, например, если должна быть выполнена *только *по завершению асинхронных операций.</p>
<p>function after(count, fn) {
let runCount = 0;
return function runAfter() {
runCount = runCount + 1;
if (runCount >= count) {
return fn.apply(this, arguments);<br>
}
}
}</p>
<p>function logResult() { console.log("calls have finished"); }
<strong>let logResultAfter2Calls = after(2, logResult);</strong></p>
<p>setTimeout(function logFirstCall() {
console.log("1st call has finished");
<strong>logResultAfter2Calls();</strong>
}, 3000);</p>
<p>setTimeout(function logSecondCall() {
console.log("2nd call has finished");
**logResultAfter2Calls(); **
}, 4000);</p>
</li>
</ul>
<p>В примере выше при помощи after() я создаю функцию logResultAfter2Calls(). Она в свою очередь выполняет logResult() только после второго вызова.</p>
<h2>throttle()</h2>
<ul>
<li>
<p><a href="https://jsfiddle.net/cristi_salcescu/5tdv0eq6/">throttle(fn, wait)</a> создает вариант функции, которая при повторяющихся вызовах выполняется через указанный временной интервал (аргумент wait). Декоратор эффективен для обработки быстро повторяющихся событий.</p>
<p>function throttle(fn, interval) {
let lastTime;
return function throttled() {
let timeSinceLastExecution = Date.now() - lastTime;
if(!lastTime || (timeSinceLastExecution >= interval)) {
fn.apply(this, arguments);
lastTime = Date.now();
}
};
}</p>
<p>let throttledProcess = throttle(process, 1000);
$(window).mousemove(throttledProcess);</p>
</li>
</ul>
<p>Здесь движение мыши генерирует множество событий mousemove, тогда как оригинальная функция process() вызывается лишь раз в секунду.</p>
<h2>debounce()</h2>
<ul>
<li>
<p><a href="https://jsfiddle.net/cristi_salcescu/424unsa7/">debounce(fn, wait)</a> создает вариант функции, которая выполняет <em>оригинальную *функцию спустя wait миллисекунд *после</em> предыдующего вызова *декорированной *функции. Паттерн также применяется в работе с повторяющимися событиями. Он полезен, если функциональность должна быть выполнена по завершению очереди событий.</p>
<p>function debounce(fn, interval) {
let timer;
return function debounced() {
clearTimeout(timer);
let args = arguments;
let that = this;
timer = setTimeout(function callOriginalFn() {
fn.apply(that, args);
}, interval);
};
}</p>
<p>let delayProcess = debounce(process, 400);
$(window).resize(delayProcess);</p>
</li>
</ul>
<p>Функция debounce() часто используется вместе с событиями scroll, resize, mousemove и keypress.</p>
<h2>Частичное применение</h2>
<p>Частичное применение преобразует функцию за счет изменения количества параметров. Это один из примеров движения от общего к частному.</p>
<h2>partial()</h2>
<p>На этот раз <a href="https://jsfiddle.net/cristi_salcescu/sbborekp/">создадим метод partial()</a> и сделаем его доступным для всех функций. В данном примере я использую синтаксис <em>ECMAScript 6</em>, а именно оператор rest. С его помощью набор аргументов функции преобразуется в массив ...leftArguments. Это нужно для конкатенации массивов, тогда как специальный объект arguments массивом не является.</p>
<pre><code>Function.prototype.partial = function(...leftArguments){
    let fn = this;
    return function partialFn(...rightArguments){
       let args = leftArguments.concat(rightArguments);
       return fn.apply(this, args);
    }
}

function log(level, message){
    console.log(level  + " : " + message);
}

**let logInfo = log.partial("Info");
logInfo("here is a message");**
</code></pre>
<p>Обратите внимание, созданная таким образом logInfo() использует лишь один аргумент message.</p>
<h2>Заключение</h2>
<p>Применение указанных функций помогает понять принципы работы декораторов и саму идею инкапсуляции логики внутри них.</p>
<p>Декораторы — мощный инструмент расширения функциональности без изменения исходной функции. Это отличный путь переиспользовать код, и он соответствует функциональной парадигме программирования.</p>
<h3><strong>Больше о ФП в JavaScript</strong></h3>
<ul>
<li>
<p><a href="https://medium.com/p/33dcb910303a">How point-free composition will make you a better functional programmer</a></p>
</li>
<li>
<p><a href="https://medium.com/p/13ba11825319">You will finally understand what Closure is</a></p>
</li>
<li>
<p><a href="https://medium.com/p/73258b6a8d15">Class vs Factory function: exploring the way forward</a> (см. <a href="https://medium.com/@kanby/%D0%BA%D0%BB%D0%B0%D1%81%D1%81-vs-%D1%84%D0%B0%D0%B1%D1%80%D0%B8%D0%BA%D0%B0-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2-%D0%BF%D0%B5%D1%80%D1%81%D0%BF%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D1%8B-9b4c696823c8">перевод</a>).</p>
</li>
<li>
<p><a href="https://medium.com/p/94fb8cc69f9d">Make your code easier to read with Functional Programming</a></p>
</li>
</ul>
<p><em>Перевод <a href="https://medium.com/@vlad_poe">Влада Почепцова</a>, редактура <a href="https://medium.com/@pepelsbey">Вадима Макеева</a>.</em></p></div></main><footer class="footer"><p>2018 © Веб-стандарты</p></footer></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.page={"componentChunkName":"component---src-templates-article-jsx","jsonName":"articles-function-decorators-a52","path":"/articles/function-decorators/"};window.dataPath="232/path---articles-function-decorators-a-52-9b0-IUfP8y9vcIi9qeFIAX5ZEFN8k";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"app":["/app-fdf6317c57abdf654ada.js"],"component---src-templates-article-list-jsx":["/component---src-templates-article-list-jsx-d6fdd15edf4f8b89c17b.js"],"component---src-templates-article-jsx":["/component---src-templates-article-jsx-da40a148dbaf87f71d30.js"],"component---src-pages-404-jsx":["/component---src-pages-404-jsx-a85f47ff49f987715412.js"],"component---src-pages-events-jsx":["/component---src-pages-events-jsx-4f883960193822a95f04.js"],"component---src-pages-index-jsx":["/component---src-pages-index-jsx-6d406cab1d4cc5f63755.js"]};/*]]>*/</script><script src="/webpack-runtime-1400fd0a68f967e222fb.js" async=""></script><script src="/app-fdf6317c57abdf654ada.js" async=""></script><script src="/component---src-templates-article-jsx-da40a148dbaf87f71d30.js" async=""></script><script src="/0-152a6e34a5c4bf7cd8a5.js" async=""></script></body></html>